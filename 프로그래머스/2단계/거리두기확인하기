function solution(places)
{
    var answer = places.map(place => {
        return place.some((row, rowIndex) => {
            return row.split('').some((column, index, arr) => {                     split안쓰고면 column은 문자열의 첫번쨰를 반환하는게 아니라 문자열 그 자체를 반환.
                if (column == 'X') return false;
                const userCount = [
                    arr[index - 1] || null, // 좌
                    arr[index + 1] || null, // 우
                    (place[rowIndex - 1] || '').charAt(index), // 상      (place[rowIndex - 1] || '')해주는 이유는 undifind일떄 .charAt()이 오류뜨기 때문에, undifind일떄 ''빈문열반환
                    (place[rowIndex + 1] || '').charAt(index), // 하
                ].filter(v => v == 'P').length;              
                
                if((column == 'P' && userCount > 0) || // P기준 상하좌우에 P가 있는지
                   (column == 'O' && userCount >= 2)) { // O기준 상하좌우에 P가 2개 이상인지
                    return true;
                }

                return false;
            }, '');
        }) ? 0 : 1;
    });

    return answer;
}

some은 배열에서 쓸수 있고 하나라도 true면 true
모두 flase면 false
기존배열의 값은 변경되지 않는다. 
arr.some(function(currentValue, index, array), thisValue)) 값, 인덱스, 배열

||는 참인거 반호나 or이다 a||b   a가먼저 평가받고 그다음에 b

charat(idx)은 문자열에서 idx번에 뭐가 있는지 찾아 반환 


조건은 p기준으로 상하좌우에 p가 하나라도 나오면 거리두기 실패고
O의 기준으로 상하좌우에 p가 2개이상 있으면 거리두기 실패임.
실패일때는 true
o랑 p 상하좌우에 거리 두기 성공이면 false, x일떄도 false
some이 하나라도 true면 true닌깐, 거리두기를 실패 했을떄 true반환
21번 라인에서 실패했을때 true닌깐 0


function solution(places) {
    let answer = [];
    
    const inBound = val => val >= 0 && val < 5;
    
    for(const place of places){
        place.map((row, idx) => {
            place[idx] = row.split('');
        });
        
        const isPerson = (r,c) => place[r][c] === 'P';
        const isEmpty = (r,c) => place[r][c] === 'O';
        
        const keepRight = place.every((row, r) => 
            row.every((seat, c) => {
                if(seat === 'P'){
                    if(inBound(r+1)){
                        if(isPerson(r+1, c)) return false;
                        if(isEmpty(r+1, c)){
                            if(inBound(c+1) && isPerson(r+1, c+1)) return false;
                            if(inBound(c-1) && isPerson(r+1, c-1)) return false;
                            if(inBound(r+2) && isPerson(r+2, c)) return false;
                        }
                    }
                    if(inBound(r-1)){
                        if(isPerson(r-1, c)) return false;
                        if(isEmpty(r-1, c)){
                            if(inBound(c+1) && isPerson(r-1, c+1)) return false;
                            if(inBound(c-1) && isPerson(r-1, c-1)) return false;
                            if(inBound(r-2) && isPerson(r-2, c)) return false;
                        }
                    }
                    if(inBound(c+1)){
                        if(isPerson(r, c+1)) return false;
                        if(isEmpty(r, c+1) && inBound(c+2) && isPerson(r, c+2)) return false;
                    }
                    if(inBound(c-1)){
                        if(isPerson(r, c-1)) return false;
                        if(isEmpty(r, c-1) && inBound(c-2) && isPerson(r, c-2)) return false;
                    }
                }
                return true;
            })
        )
        answer.push(keepRight ? 1 : 0);
    }
    
    return answer;
}

