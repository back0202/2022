const solution = (expression) => {
  const arr = [                                           1.조합은 최대6개
    ["+", "-", "*"],
    ["+", "*", "-"],
    ["-", "+", "*"],
    ["-", "*", "+"],
    ["*", "+", "-"],
    ["*", "-", "+"],
  ];


  let num = expression.split(/[^0-9]/);                2.숫자만 분리
  num = num.map((it) => {                              3.문자열을 숫자로
    return parseInt(it);
  });
  const sign = [];                                     4. 수식어 분리
  for (let i = 0; i < expression.length; i++) {
    if (
      expression[i] === "*" ||
      expression[i] === "+" ||
      expression[i] === "-"
    ) {
      sign.push(expression[i]);
    }
  }

  let maxNum = 0;                                      5.최댓값
  for (let i = 0; i < arr.length; i++) {
    //2. 배열과 수식을 복사한다.
    const copyNum = num.slice();                       6. 복사해주는 이유는 6번반복해야하는데 밑에 splice로 원소를 삭제하기때문에
    const copySign = sign.slice();
    for (let j = 0; j < arr[i].length; j++) {
      for (let k = 0; k < copySign.length; k++) {
        if (copySign[k] === arr[i][j]) {             7. 1번의 맨앞과 같다면
          if (copySign[k] === "*") {                 같은게 *일뗴
            copyNum[k] *= copyNum[k + 1];            숫자의[k]번째숫자와 그 다음 숫자를 *해주고 그자리에 넣어주는거 한번에 [1,2,3]이면 2번자리에 [1,6,3]이렇게
            copyNum.splice(k + 1, 1);                그다음은 더한거 원소에서 삭제 해주고
            copySign.splice(k, 1);                   사용한 수식도 삭제
            k--;                                     [1,2,3]에서 2번을 삭제해주면 [1,3]이된다. 이떄 3번원소는 2번인덱스에서 1번인덱스로 바뀐다. 한칸 앞으로 인덱스가 변경되기 때문에 다음 반복을 진행하면 원소 하나를 그냥 지나침
          } else if (copySign[k] === "+") {
            copyNum[k] += copyNum[k + 1];
            copyNum.splice(k + 1, 1);
            copySign.splice(k, 1);
            k--;
          } else {
            copyNum[k] -= copyNum[k + 1];
            copyNum.splice(k + 1, 1);
            copySign.splice(k, 1);
            k--;
          }
        }
      }
    }
    
    if (Math.abs(copyNum[0]) >= maxNum) {
      maxNum = Math.abs(copyNum[0]);
    }
  }
  return maxNum;
};
