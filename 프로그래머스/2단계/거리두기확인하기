function solution(places)
{
    var answer = places.map(place => {
        return place.some((row, rowIndex) => {
            return row.split('').some((column, index, arr) => {
                if (column == 'X') return false;
                const userCount = [
                    arr[index - 1] || null, // 좌
                    arr[index + 1] || null, // 우
                    (place[rowIndex - 1] || '').charAt(index), // 상      (place[rowIndex - 1] || '')해주는 이유는 undifind일떄 .charAt()이 오류뜨기 때문에, undifind일떄 ''빈문열반환
                    (place[rowIndex + 1] || '').charAt(index), // 하
                ].filter(v => v == 'P').length;              
                
                if((column == 'P' && userCount > 0) || // P기준 상하좌우에 P가 있는지
                   (column == 'O' && userCount >= 2)) { // O기준 상하좌우에 P가 2개 이상인지
                    return true;
                }

                return false;
            }, '');
        }) ? 0 : 1;
    });

    return answer;
}

some은 배열에서 쓸수 있고 하나라도 true면 true
모두 flase면 false
기존배열의 값은 변경되지 않는다. 
arr.some(function(currentValue, index, array), thisValue)) 값, 인덱스, 배열

||는 참인거 반호나 or이다 a||b   a가먼저 평가받고 그다음에 b

charat(idx)은 문자열에서 idx번에 뭐가 있는지 찾아 반환 


조건은 p기준으로 상하좌우에 p가 하나라도 나오면 거리두기 실패고
O의 기준으로 상하좌우에 p가 2개이상 있으면 거리두기 실패임.
some이 하나라도 true면 true닌깐, 거리두기를 실패 했을떄 true반환
21번 라인에서 실패했을때 true닌깐 0
